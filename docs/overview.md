# Vibe Coding 概述

## 什么是 Vibe Coding？

> **Vibe Coding = AI 代理 + 结构化上下文 + 质量门控 + 多代理协作**

Vibe Coding（氛围编程/AI 驱动协作开发）是一种新型的软件开发方法论，核心思想是：

**开发者负责"什么"和"为什么"，AI 负责"怎么做"。**

## 与传统开发的区别

| 传统开发 | Vibe Coding |
|---------|-------------|
| 开发者编写每一行代码 | 开发者描述需求，AI 生成代码 |
| 文档事后补写 | 上下文即文档，实时维护 |
| 单人或团队人工协作 | 人与 AI 协作，多 AI 并行 |
| 知识分散在个人大脑 | 知识结构化存储在 Skill 库 |

## 核心特征

### 1. 约定优于配置（Convention over Configuration）

SKILL 不是可选的参考资料，而是**强制执行的工作约定**：

```
用户: "提交代码"
      ↓
AI 读取 SKILL.md → 找到 "AI 助手约定" 章节
      ↓
AI 执行约定的流程（精确添加、规范提交）
      ↓
用户得到一致、可预期的结果
```

- **[强制]** 标记的规则 AI 必须执行
- **[禁止]** 标记的操作 AI 绝不能做
- **[OK]** 标记的做法 AI 应该采用

### 2. 渐进式披露（Progressive Disclosure）

不是一次性给 AI 所有信息，而是分层加载：

```
Level 1: Skill 元数据（name/description）
    ↓ 触发后加载
Level 2: SKILL.md（核心工作流程）
    ↓ 需要时加载
Level 3: References（详细资料）
```

### 3. 学习中演进

被动式经验沉淀，能力持续成长：

```
项目交付中发现问题
        ↓
快速记录 → 直接更新 SKILL（无需清洗）
        ↓
能力层升级 → 支撑更好的交付
```

**两条输入路径**：
- **主动学习**：外部资料 → 数据清洗 → SKILL
- **实践沉淀**：项目经验 → 直接写入 SKILL

## 适用场景

### [OK] 适合 Vibe Coding

- 有明确需求但实现细节复杂的任务
- 需要大量样板代码的重复性工作
- 跨领域开发（需要查阅大量文档）
- 快速原型开发

### [X] 不适合 Vibe Coding

- 需求完全不明确的探索性任务
- 对安全性要求极高的核心系统
- 需要深度创造性设计的架构工作

## 与 OpenClaw 的关系

Vibe Coding 方法论提炼自 **OpenClaw** 项目的实践：

| OpenClaw 组件 | 对应 Vibe Coding 概念 |
|--------------|---------------------|
| `AGENTS.md` | 项目开发指南 |
| `skills/` | Skill 库 |
| `.agents/skills/` | PR 工作流技能 |
| `scripts/committer` | 精确提交规范 |
| 质量门 | 强制检查流程 |

OpenClaw 是 Vibe Coding 的一个完整实现，但 Vibe Coding 方法论可以应用到任何项目中。

## 核心收益

1. **知识沉淀**：开发经验结构化存储，不再随人员流失
2. **效率提升**：AI 处理重复工作，人专注于创造性工作
3. **质量保证**：标准化流程减少错误
4. **可扩展性**：多 AI 并行工作，突破个人效率瓶颈

## 三种约定层次

Vibe Coding 采用三层约定体系：

| 层次 | 定义 | 载体 | 演进方式 |
|------|------|------|----------|
| **全局约定** | AI 的"本性"原则 | `vibe-coding/core` | 多次项目经验升华 |
| **能力约定** | 领域内做事方法 | 各 `SKILL.md` | 被动式经验沉淀 |
| **项目/任务约定** | 具体场景约束 | `AGENTS.md` | 任务开始时定义 |

## 下一步

- 了解 [五层架构](architecture.md)
- 学习 [三种核心理念与五阶段流程](methodology.md)
- 掌握 [实施流程](workflow.md)
