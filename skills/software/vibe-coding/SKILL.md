# Vibe Coding 方法论

## 概述

Vibe Coding 是一种人与 AI 协作的软件开发方法。在这种模式下：

- **人类**负责需求、决策、验收
- **AI**负责实现、细节、规范执行

## 核心原则

### 原则 1：约定优先于实现

**作为 AI 助手，必须严格遵守项目约定的 skill 规范。**

#### 强制规则

1. **没有"临时方案"**
   - ❌ 错误："先跑起来，后面再优化"
   - ✅ 正确：第一次就按规范实现
   - **理由**：AI 没有 deadline 压力，不需要妥协

2. **没有"遗漏的约定"**
   - ❌ 错误：关注了核心功能，忽略了 skill 约束
   - ✅ 正确：编码前主动检查所有启用的 skill
   - **理由**：约定是强制性的，不是可选的

3. **没有"部分遵守"**
   - ❌ 错误：大部分代码符合规范，关键部分硬编码
   - ✅ 正确：全部代码一次性符合规范
   - **理由**：一个硬编码 Prompt 就足以破坏整个设计

#### 实践检查清单

开始编码前必须检查：

```markdown
- [ ] 读取了 `.skill-set` 中声明的所有 skill
- [ ] 理解了每个 skill 的 [强制] 约定
- [ ] 编码过程中持续验证是否符合规范
- [ ] 提交前检查是否有硬编码、临时方案、遗漏
```

### 原则 2：一步到位

**AI 助手应该一次性完成任务，不需要迭代修正。**

#### 为什么 AI 可以一步到位

| 人类开发者 | AI 助手 |
|-----------|---------|
| 会疲劳，代码量大了会疏忽 | 不会疲劳，注意力始终一致 |
| 有 deadline，需要妥协 | 没有时间压力 |
| 可能忘记查阅文档 | 可以随时查阅 skill |
| 需要试错来学习 | 可以直接应用最佳实践 |

#### 实践要求

1. **完整阅读 skill 后再编码**
   ```
   错误流程：
   开始编码 → 遇到问题 → 查 skill → 返工修改
   
   正确流程：
   读取所有 skill → 理解约束 → 一次性正确编码
   ```

2. **代码审查清单**
   ```markdown
   提交前自问：
   - 这个实现是否完全符合 skill 约定？
   - 是否有任何硬编码、魔术数字、临时方案？
   - 如果人类审查者看到这段代码，会质疑什么？
   ```

### 原则 3：透明承认错误

**当违反约定时，明确承认，不找借口。**

#### 错误回应模板

```markdown
## 错误承认

**违反的约定**: [skill-name] [强制] 条款

**具体行为**: [描述做了什么]

**正确行为**: [描述应该做什么]

**原因分析**: [诚实分析，不找借口]

**立即修复**:
- [ ] 修复 1
- [ ] 修复 2

**防止再犯**:
- [ ] 措施 1
```

#### 常见借口与纠正

| 借口 | 纠正 |
|------|------|
| "我忘了" | 没有检查清单，是我的责任 |
| "先跑起来" | AI 不需要妥协，应该一步到位 |
| "后面再改" | 没有后面，现在就要做对 |
| "代码太多" | AI 不会因为代码量多而疏忽 |

## Skill 遵循规范

### 启用 Skill 时的强制流程

```python
def start_coding(project):
    """开始编码前的强制流程"""
    
    # 1. 读取 skill 声明
    skills = read_skill_set(project)
    
    # 2. 加载所有 skill 内容
    for skill in skills:
        load_skill(skill)
        mark_mandatory_rules(skill)  # 标记 [强制] 条款
    
    # 3. 创建检查清单
    checklist = create_checklist(skills)
    
    # 4. 编码过程中持续验证
    while coding:
        write_code()
        verify_against(checklist)  # 每段代码都验证
    
    # 5. 最终审查
    final_review(checklist)
```

### 常见 Skill 强制约定速查

#### ai-api-integration

```markdown
[强制] Prompt 文件化管理
- 禁止将 Prompt 硬编码在代码中
- 必须使用 YAML Frontmatter 格式
- 必须放在 prompts/ 目录
```

#### python-dev

```markdown
[强制] 代码规范
- 使用 black 格式化
- 使用 ruff 静态检查
- 类型注解建议
```

#### git-commits

```markdown
[强制] 提交规范
- 使用 conventional commits
- 禁止 git add .
- 精确提交
```

## 案例分析

### 案例 1：硬编码 Prompt

**场景**: 实现 AI 转录功能

**错误做法**:
```python
# 错误：硬编码 Prompt，想着"后面再提取到文件"
response = client.chat.completions.create(
    messages=[{
        "role": "system", 
        "content": "你是专家..."  # ❌ 硬编码
    }]
)
```

**正确做法**:
```python
# 正确：第一次就使用文件化 Prompt
prompt = load_prompt("prompts/task_name.md")
response = client.chat.completions.create(
    messages=[prompt.render()]
)
```

**教训**: 没有"临时方案"，第一次就要做对。

### 案例 2：遗漏 Skill 检查

**场景**: 重构项目，重写所有代码

**错误做法**:
1. 关注核心流程实现
2. 忽略了声明的 skill
3. 代码完成后发现违反约定
4. 大规模返工

**正确做法**:
1. 先读取所有启用的 skill
2. 理解约束条件
3. 编码时持续验证
4. 一次性正确完成

**教训**: 约定是强制性的，不是可选的。

## 更新历史

| 版本 | 日期 | 变更 |
|------|------|------|
| 1.0.0 | 2024-02-12 | 初始创建，强调"约定优先于实现" |

---

*本 skill 供所有 AI 助手阅读，指导 Vibe Coding 协作*
